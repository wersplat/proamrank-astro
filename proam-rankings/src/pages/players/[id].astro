---
import Navigation from "../../components/Navigation.astro";
import PlayerTabs from "../../components/player/Tabs";
import { supa } from "../../lib/supabase";
import "../../styles/global.css";

// Enable SSR for dynamic player pages
export const prerender = false;

const { id } = Astro.params;

// Fetch recent games (limited to recent 25 for initial display)
const GAMES_LIMIT = 25;

// Get player basic info (including social media and alternate gamertag)
const { data: playerData } = await supa(Astro.locals)
  .from("players")
  .select("id, gamertag, alternate_gamertag, position, player_rp, performance_score, salary_tier, current_team_id, currentTeamName, twitter_id, discord_id, twitch")
  .eq("id", id!)
  .maybeSingle();

// Use player_performance_mart for optimized performance data
const { data: perfData } = await supa(Astro.locals)
  .from("player_performance_mart")
  .select("*")
  .eq("player_id", id!)
  .maybeSingle();

// Get player tracking data (career highs, milestones, etc.) from player_stats_tracking_mart
const { data: trackingData } = await supa(Astro.locals)
  .from("player_stats_tracking_mart")
  .select("*")
  .eq("player_id", id!)
  .maybeSingle();

// Get player form/streak data from player_hot_streak_mart
const { data: streakData } = await supa(Astro.locals)
  .from("player_hot_streak_mart")
  .select("*")
  .eq("player_id", id!)
  .maybeSingle();

// Get detailed global rating breakdown from v_player_global_rating view (fallback for breakdown only)
const { data: ratingData } = await supa(Astro.locals)
  .from("v_player_global_rating")
  .select("*")
  .eq("player_id", id!)
  .maybeSingle();

// ALWAYS use player_performance_mart.global_rating as the primary source (never player_performance_view)
// Use v_player_global_rating view only for detailed breakdown components if available
const globalRatingData = perfData ? {
  player_id: perfData.player_id,
  gamertag: perfData.gamertag,
  position: perfData.position,
  // PRIMARY SOURCE: Always use performance mart for global_rating (matches players index page)
  global_rating: parseFloat(String(perfData.global_rating || '0')),
  rating_tier: perfData.rating_tier,
  total_games: perfData.games_played || 0,
  recent_games: perfData.games_played || 0, // Approximate for now
  // Detailed breakdown: use v_player_global_rating view data if available (NOT player_performance_view)
  base_rating: ratingData ? parseFloat(String(ratingData.base_rating || '0')) : 0,
  game_impact: ratingData ? parseFloat(String(ratingData.game_impact || '0')) : 0,
  event_bonus: ratingData ? parseFloat(String(ratingData.event_bonus || '0')) : 0,
  decay_penalty: ratingData ? parseFloat(String(ratingData.decay_penalty || '0')) : 0,
  consistency_bonus: ratingData ? parseFloat(String(ratingData.consistency_bonus || '0')) : 0,
  days_since_last_game: ratingData ? ratingData.days_since_last_game : null,
  peak_performance: ratingData ? parseFloat(String(ratingData.peak_performance || '0')) : 0,
} : null;

// Get current team info if player has one - use team_analytics_mart
let currentTeam = null;
if (playerData?.current_team_id) {
  const { data: teamData } = await supa(Astro.locals)
    .from("team_analytics_mart")
    .select("team_id, team_name, logo_url, elo_rating, current_rp")
    .eq("team_id", playerData.current_team_id)
    .maybeSingle();
  
  if (teamData) {
    currentTeam = {
      id: teamData.team_id,
      name: teamData.team_name,
      logo_url: teamData.logo_url,
      global_rank: null, // Not in mart but not critical for display
    };
  }
}

// Get recent games (limited for initial display)
const { data: statsData } = await supa(Astro.locals)
  .from("player_stats")
  .select("id, match_id, points, assists, rebounds, steals, blocks, turnovers, fgm, fga, three_points_made, three_points_attempted, created_at")
  .eq("player_id", id!)
  .order("created_at", { ascending: false })
  .limit(GAMES_LIMIT);

// Get match info for games
const matchIds = (statsData ?? []).map((s: any) => s.match_id).filter(Boolean);
const { data: matchesData } = matchIds.length > 0 ? await supa(Astro.locals)
  .from("v_matches_with_primary_context")
  .select("id, played_at, team_a_id, team_b_id, score_a, score_b, boxscore_url, status, verified, league_id, season_id, tournament_id, stage")
  .in("id", matchIds) : { data: [] };

const matchMap = new Map((matchesData ?? []).map((m: any) => [m.id, m]));

// Get team info for matches
const teamIds = Array.from(new Set([
  ...(matchesData ?? []).map((m: any) => m.team_a_id),
  ...(matchesData ?? []).map((m: any) => m.team_b_id)
].filter(Boolean)));

const { data: teamsData } = teamIds.length > 0 ? await supa(Astro.locals)
  .from("teams")
  .select("id, name, logo_url")
  .in("id", teamIds) : { data: [] };

const teamMap = new Map((teamsData ?? []).map((t: any) => [t.id, t]));

// Get league info (use season_id for accurate season lookup)
const seasonIds = Array.from(new Set((matchesData ?? []).map((m: any) => m.season_id).filter(Boolean)));
const { data: leaguesData } = seasonIds.length > 0 ? await supa(Astro.locals)
  .from("league_calendar")
  .select("season_id, league_id, league_name, season_number")
  .in("season_id", seasonIds) : { data: [] };

const leagueMap = new Map((leaguesData ?? []).map((l: any) => [l.season_id, l]));

// Get tournament info
const tournamentIds = Array.from(new Set((matchesData ?? []).map((m: any) => m.tournament_id).filter(Boolean)));
const { data: tournamentsData } = tournamentIds.length > 0 ? await supa(Astro.locals)
  .from("tournaments")
  .select("id, name")
  .in("id", tournamentIds) : { data: [] };

const tournamentMap = new Map((tournamentsData ?? []).map((t: any) => [t.id, t]));

// Combine game stats with match info
const games = (statsData ?? []).map((s: any) => {
  const match = matchMap.get(s.match_id);
  return {
    ...s,
    matches: match ? {
      ...match,
      team_a: teamMap.get(match.team_a_id),
      team_b: teamMap.get(match.team_b_id),
      league: leagueMap.get(match.season_id),
      tournament: tournamentMap.get(match.tournament_id),
    } : null,
  };
});

const player = playerData;
const performance = perfData; // From player_performance_mart
const recentGames = games;
const globalRating = globalRatingData;
const careerTracking = trackingData; // From player_stats_tracking_mart
const formStreak = streakData; // From player_hot_streak_mart

if (!player) {
  return Astro.redirect("/players");
}
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{player.gamertag} - Pro-Am Rankings</title>
  </head>
  <body class="bg-brand-navy text-white">
    <Navigation />
    <main class="mx-auto max-w-6xl p-6">
      <!-- Player Header -->
      <div class="mb-8">
        <h1 class="text-3xl font-bold mb-2">{player.gamertag}</h1>
        <div class="flex flex-wrap gap-4 text-sm mb-4">
          <div>
            <span class="text-neutral-400">Position:</span>
            <span class="ml-2 font-semibold">{player.position || 'Unknown'}</span>
          </div>
          {currentTeam && (
            <div>
              <span class="text-neutral-400">Team:</span>
              <a href={`/teams/${currentTeam.id}`} class="ml-2 font-semibold hover:text-blue-400">
                {currentTeam.name}
              </a>
            </div>
          )}
          <div>
            <span class="text-neutral-400">Tier:</span>
            <span class="ml-2 font-semibold">{player.salary_tier || '-'}</span>
          </div>
        </div>
      </div>

      <!-- Tabbed Interface with all player sections -->
      <PlayerTabs 
        client:load 
        player={player} 
        team={currentTeam}
        recentGames={recentGames}
        playerId={id!}
        performance={performance}
        globalRating={globalRating}
      />
    </main>
  </body>
</html>