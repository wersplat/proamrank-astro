---
import Navigation from "../../components/Navigation.astro";
import SpotlightMatchup from "../../components/SpotlightMatchup";
import { supa } from "../../lib/supabase";
import "../../styles/global.css";

// Enable SSR for dynamic matchup pages
export const prerender = false;

const { id } = Astro.params;

if (!id) {
  return Astro.redirect("/");
}

// Get match details - try upcoming_matches first, then fall back to matches
let matchData: any = null;

// First try upcoming_matches
const { data: upcomingMatchData } = await supa((Astro.locals as any).runtime)
  .from("upcoming_matches")
  .select("*")
  .eq("id", id)
  .maybeSingle();

if (upcomingMatchData) {
  matchData = upcomingMatchData;
} else {
  // Fall back to regular matches table
  const { data: regularMatchData } = await supa((Astro.locals as any).runtime)
    .from("v_matches_with_primary_context")
    .select("*")
    .eq("id", id)
    .maybeSingle();
  
  if (regularMatchData) {
    // For Final 4/Finals matches, try to find corresponding upcoming match
    const validStages = ["Semi Finals", "Finals", "Grand Finals"];
    if (regularMatchData.stage && validStages.includes(regularMatchData.stage) && 
        regularMatchData.team_a_id && regularMatchData.team_b_id) {
      // Look for upcoming match with same teams, stage, and tournament/league context
      const { data: correspondingUpcomingMatch } = await supa((Astro.locals as any).runtime)
        .from("upcoming_matches")
        .select("*")
        .eq("team_a_id", regularMatchData.team_a_id)
        .eq("team_b_id", regularMatchData.team_b_id)
        .eq("stage", regularMatchData.stage);
      
      // Check tournament or league context match
      let upcomingMatch = null;
      if (regularMatchData.tournament_id) {
        upcomingMatch = correspondingUpcomingMatch?.find((um: any) => um.tournament_id === regularMatchData.tournament_id);
      } else if (regularMatchData.league_id && regularMatchData.season_id) {
        upcomingMatch = correspondingUpcomingMatch?.find((um: any) => 
          um.league_id === regularMatchData.league_id && um.season_id === regularMatchData.season_id);
      }
      
      if (upcomingMatch) {
        matchData = upcomingMatch;
      } else {
        matchData = regularMatchData;
      }
    } else {
      matchData = regularMatchData;
    }
  }
}

if (!matchData) {
  return Astro.redirect("/");
}

// Check if this is a Final 4 or Finals match
const validStages = ["Semi Finals", "Finals", "Grand Finals"];
if (!(matchData as any).stage || !validStages.includes((matchData as any).stage)) {
  return Astro.redirect("/");
}

// Get team details - ensure we have valid team IDs
if (!matchData.team_a_id || !matchData.team_b_id) {
  return Astro.redirect("/");
}

const { data: teamsData } = await supa((Astro.locals as any).runtime)
  .from("teams")
  .select("id, name, logo_url")
  .in("id", [matchData.team_a_id, matchData.team_b_id]);

const teamMap = new Map((teamsData ?? []).map((t: any) => [t.id, t]));
const teamA = teamMap.get(matchData.team_a_id);
const teamB = teamMap.get(matchData.team_b_id);

if (!teamA || !teamB) {
  return Astro.redirect("/");
}

// Get tournament context info
let tournamentInfo = null;
let organizerTwitch = null;

if (matchData.tournament_id) {
  const { data: tournament } = await supa((Astro.locals as any).runtime)
    .from("tournaments")
    .select(`
      id,
      name,
      organizer:leagues_info!tournaments_organizer_id_fkey (
        twitch_url,
        lg_url,
        lg_discord
      )
    `)
    .eq("id", matchData.tournament_id)
    .maybeSingle();

  if (tournament) {
    tournamentInfo = {
      id: tournament.id || '',
      name: tournament.name || ''
    };
    organizerTwitch = tournament.organizer?.twitch_url || null;
  }
}

// Get team rosters - use league_season_team_rosters for open/playoff tournaments, tournament_team_rosters for standalone tournaments
const getTeamRoster = async (teamId: string, matchContext: any) => {
  let rosterData: any[] = [];

  // Check if this is a league-based tournament (open/playoff) with league_id and season_id
  if (matchContext.league_id && matchContext.season_id) {
    // Use league_season_team_rosters for open and playoff tournaments
    const { data: leagueRosterData } = await supa((Astro.locals as any).runtime)
      .from("league_season_team_rosters")
      .select("player_id, player_name")
      .eq("team_id", teamId)
      .eq("league_id", matchContext.league_id)
      .eq("season_id", matchContext.season_id);

    rosterData = leagueRosterData || [];
  } 
  
  // If no league roster found, try tournament-specific roster for standalone tournaments
  if ((!rosterData || rosterData.length === 0) && matchContext.tournament_id) {
    const { data: tournamentRosterData } = await supa((Astro.locals as any).runtime)
      .from("tournament_team_rosters")
      .select("player_id, player_name")
      .eq("team_id", teamId)
      .eq("tournament_id", matchContext.tournament_id);

    rosterData = tournamentRosterData || [];
  }

  if (!rosterData || rosterData.length === 0) return [];

  // Get player details including Twitch info
  const playerIds = rosterData.map((p: any) => p.player_id).filter(Boolean);
  const { data: playersData } = await supa((Astro.locals as any).runtime)
    .from("players")
    .select("id, gamertag, position, salary_tier, twitch, twitter_id, discord_id")
    .in("id", playerIds);

  const playerMap = new Map((playersData ?? []).map((p: any) => [p.id, p]));

  return rosterData.map((rosterEntry: any) => {
    const player = playerMap.get(rosterEntry.player_id);
    return {
      player_id: rosterEntry.player_id,
      gamertag: player?.gamertag || rosterEntry.player_name,
      position: player?.position || null,
      salary_tier: player?.salary_tier || null,
      twitch: player?.twitch || null,
      discord_id: player?.discord_id || null
    };
  }).filter((p: any) => p.player_id); // Filter out entries without valid player IDs
};

// Get team rosters - ensure we have valid team IDs
const teamARoster = matchData.team_a_id ? 
  await getTeamRoster(matchData.team_a_id, matchData) : [];
const teamBRoster = matchData.team_b_id ? 
  await getTeamRoster(matchData.team_b_id, matchData) : [];

// Get player stats - try league_open_player_stats and league_playoff_player_stats first, then fallback to tournament stats
const getPlayerStats = async (teamId: string, matchContext: any) => {
  // Try league_open_player_stats first if we have league and season context
  if (matchContext.league_id && matchContext.season_id) {
    // Check open stats first
    const { data: leagueOpenStats } = await supa((Astro.locals as any).runtime)
      .from("league_open_player_stats")
      .select("*")
      .eq("team_id", teamId)
      .eq("league_id", matchContext.league_id)
      .eq("season_id", matchContext.season_id);

    if (leagueOpenStats && leagueOpenStats.length > 0) {
      const statsMap = new Map();
      leagueOpenStats.forEach((stat: any) => {
        if (stat.player_id) {
          statsMap.set(stat.player_id, {
            avg_points: stat.avg_points || 0,
            avg_assists: stat.avg_assists || 0,
            avg_rebounds: stat.avg_rebounds || 0,
            avg_steals: stat.avg_steals || 0,
            avg_blocks: stat.avg_blocks || 0,
            games_played: stat.games_played || 0
          });
        }
      });
      return statsMap;
    }

    // Try playoff stats if no open stats found
    const { data: leaguePlayoffStats } = await supa((Astro.locals as any).runtime)
      .from("league_playoff_player_stats")
      .select("*")
      .eq("team_id", teamId)
      .eq("league_id", matchContext.league_id)
      .eq("season_id", matchContext.season_id);

    if (leaguePlayoffStats && leaguePlayoffStats.length > 0) {
      const statsMap = new Map();
      leaguePlayoffStats.forEach((stat: any) => {
        if (stat.player_id) {
          statsMap.set(stat.player_id, {
            avg_points: stat.avg_points || 0,
            avg_assists: stat.avg_assists || 0,
            avg_rebounds: stat.avg_rebounds || 0,
            avg_steals: stat.avg_steals || 0,
            avg_blocks: stat.avg_blocks || 0,
            games_played: stat.games_played || 0
          });
        }
      });
      return statsMap;
    }
  }

  // Fallback to tournament-specific stats if league stats not available
  if (matchContext.tournament_id) {
    const { data: tournamentMatches } = await supa((Astro.locals as any).runtime)
      .from("v_matches_with_primary_context")
      .select("id")
      .eq("primary_tournament_id", matchContext.tournament_id)
      .or(`team_a_id.eq.${teamId},team_b_id.eq.${teamId}`);

    if (!tournamentMatches || tournamentMatches.length === 0) return new Map();

    const matchIds = tournamentMatches.map((m: any) => m.id);

    // Get player stats for all tournament matches
    const { data: playerStats } = await supa((Astro.locals as any).runtime)
      .from("player_stats")
      .select("player_id, points, assists, rebounds, steals, blocks, match_id")
      .in("match_id", matchIds)
      .eq("team_id", teamId);

    if (!playerStats || playerStats.length === 0) return new Map();

    // Calculate averages per player
    const playerStatsMap = new Map();
    
    playerStats.forEach((stat: any) => {
      if (!playerStatsMap.has(stat.player_id)) {
        playerStatsMap.set(stat.player_id, {
          player_id: stat.player_id,
          games_played: 0,
          total_points: 0,
          total_assists: 0,
          total_rebounds: 0,
          total_steals: 0,
          total_blocks: 0
        });
      }
      
      const playerStat = playerStatsMap.get(stat.player_id);
      playerStat.games_played += 1;
      playerStat.total_points += stat.points || 0;
      playerStat.total_assists += stat.assists || 0;
      playerStat.total_rebounds += stat.rebounds || 0;
      playerStat.total_steals += stat.steals || 0;
      playerStat.total_blocks += stat.blocks || 0;
    });

    // Calculate averages
    const avgStats = new Map();
    playerStatsMap.forEach((stats, playerId) => {
      avgStats.set(playerId, {
        avg_points: stats.games_played > 0 ? stats.total_points / stats.games_played : 0,
        avg_assists: stats.games_played > 0 ? stats.total_assists / stats.games_played : 0,
        avg_rebounds: stats.games_played > 0 ? stats.total_rebounds / stats.games_played : 0,
        avg_steals: stats.games_played > 0 ? stats.total_steals / stats.games_played : 0,
        avg_blocks: stats.games_played > 0 ? stats.total_blocks / stats.games_played : 0,
        games_played: stats.games_played
      });
    });

    return avgStats;
  }

  return new Map();
};

// Get player stats using the new function that tries league_open_player_stats first
const teamAPlayerStats = matchData.team_a_id ? 
  await getPlayerStats(matchData.team_a_id, matchData) : new Map();
const teamBPlayerStats = matchData.team_b_id ? 
  await getPlayerStats(matchData.team_b_id, matchData) : new Map();

// Filter rosters to only include players who have stats in open/playoffs/tournament
const filteredTeamARoster = teamARoster.filter((player: any) => 
  teamAPlayerStats.has(player.player_id)
);
const filteredTeamBRoster = teamBRoster.filter((player: any) => 
  teamBPlayerStats.has(player.player_id)
);

// Get tournament team stats
const getTournamentTeamStats = async (teamId: string, tournamentId: string) => {
  if (!tournamentId) return null;

  // Try to get from tournament_results first
  const { data: resultData } = await supa((Astro.locals as any).runtime)
    .from("tournament_results")
    .select("wins, losses, points_for, points_against, final_placement")
    .eq("team_id", teamId)
    .eq("tournament_id", tournamentId)
    .maybeSingle();

  if (resultData) {
    return {
      wins: resultData.wins || 0,
      losses: resultData.losses || 0,
      points_for: resultData.points_for || 0,
      points_against: resultData.points_against || 0,
      final_placement: resultData.final_placement
    };
  }

  return null;
};

const teamAStats = matchData.tournament_id && matchData.team_a_id ? 
  await getTournamentTeamStats(matchData.team_a_id, matchData.tournament_id) : null;
const teamBStats = matchData.tournament_id && matchData.team_b_id ? 
  await getTournamentTeamStats(matchData.team_b_id, matchData.tournament_id) : null;

// Get head-to-head matchup data if previous meetings exist
let headToHeadData = null;
if (matchData.team_a_id && matchData.team_b_id) {
  // Get the teams in canonical order for head-to-head lookup
  const team1Id = matchData.team_a_id < matchData.team_b_id ? matchData.team_a_id : matchData.team_b_id;
  const team2Id = matchData.team_a_id < matchData.team_b_id ? matchData.team_b_id : matchData.team_a_id;
  
  const { data: h2hData } = await supa((Astro.locals as any).runtime)
    .from("head_to_head_matchup_mart")
    .select("*")
    .eq("team_1_id", team1Id)
    .eq("team_2_id", team2Id)
    .maybeSingle();
  
  if (h2hData) {
    headToHeadData = {
      total_meetings: h2hData.total_meetings || 0,
      team_1_wins: h2hData.team_1_wins || 0,
      team_2_wins: h2hData.team_2_wins || 0,
      team_1_avg_score: h2hData.team_1_avg_score || 0,
      team_2_avg_score: h2hData.team_2_avg_score || 0,
      avg_score_differential: h2hData.avg_score_differential || 0,
      last_meeting: h2hData.last_meeting || null,
      days_since_last_meeting: h2hData.days_since_last_meeting || null,
      current_winner: h2hData.current_winner || null,
      team_1_last_5_wins: h2hData.team_1_last_5_wins || 0,
      team_2_last_5_wins: h2hData.team_2_last_5_wins || 0,
      // Determine which team is which based on the canonical ordering
      team_a_wins: team1Id === matchData.team_a_id ? h2hData.team_1_wins || 0 : h2hData.team_2_wins || 0,
      team_b_wins: team1Id === matchData.team_a_id ? h2hData.team_2_wins || 0 : h2hData.team_1_wins || 0,
    };
  }
}

// Determine if this is from upcoming_matches or regular matches
const isUpcomingMatch = !!(matchData as any).scheduled_at; // upcoming_matches has scheduled_at, matches doesn't

// Prepare the match object with all data
const spotlightMatch = {
  id: matchData.id,
  played_at: isUpcomingMatch ? matchData.scheduled_at : matchData.played_at,
  stage: (matchData as any).stage,
  team_a_id: matchData.team_a_id,
  team_b_id: matchData.team_b_id,
  score_a: isUpcomingMatch ? null : matchData.score_a, // upcoming matches don't have scores yet
  score_b: isUpcomingMatch ? null : matchData.score_b, // upcoming matches don't have scores yet
  winner_id: isUpcomingMatch ? null : matchData.winner_id, // upcoming matches don't have winners yet
  team_a: {
    id: teamA.id,
    name: teamA.name,
    logo_url: teamA.logo_url,
    roster: filteredTeamARoster,
    player_stats: teamAPlayerStats,
    tournament_stats: teamAStats
  },
  team_b: {
    id: teamB.id,
    name: teamB.name,
    logo_url: teamB.logo_url,
    roster: filteredTeamBRoster,
    player_stats: teamBPlayerStats,
    tournament_stats: teamBStats
  },
  tournament: tournamentInfo,
  organizer_twitch: organizerTwitch,
  head_to_head: headToHeadData
};

---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{spotlightMatch.stage} - {spotlightMatch.team_a.name} vs {spotlightMatch.team_b.name} - Pro-Am Rankings</title>
  </head>
  <body class="bg-brand-navy text-white">
    <Navigation />
    <main class="mx-auto max-w-6xl p-6">
      <SpotlightMatchup match={spotlightMatch} />
    </main>
  </body>
</html>
