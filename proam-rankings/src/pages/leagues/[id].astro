---
import Navigation from "../../components/Navigation.astro";
import LeagueTabsIsland from "../../components/LeagueTabsIsland";
import { supa } from "../../lib/supabase";
import "../../styles/global.css";

// Enable SSR for dynamic league pages
export const prerender = false;

const { id } = Astro.params;

if (!id) {
  return Astro.redirect("/leagues");
}

// Use league_season_performance_mart for optimized league season info
const { data: leagueData } = await supa((Astro.locals as any).runtime)
  .from("league_season_performance_mart")
  .select("*")
  .eq("season_id", id)
  .maybeSingle();

// Use id directly as season_id
const seasonId = id;

// Load entry fee and prize pool from league_seasons table if we have a season_id
let entryFee: number | null = null;
let prizePool: number | null = null;
if (seasonId) {
  const { data: seasonData } = await supa((Astro.locals as any).runtime)
    .from("league_seasons")
    .select("entry_fee, prize_pool")
    .eq("id", seasonId)
    .maybeSingle();
  
  if (seasonData) {
    entryFee = seasonData.entry_fee;
    prizePool = seasonData.prize_pool;
  }
}

// Get additional league info if we have a league_id
let leagueInfo: any = null;
if (leagueData?.league_id) {
  const { data: info } = await supa((Astro.locals as any).runtime)
    .from("leagues_info")
    .select("id, league, lg_logo_url, lg_url, lg_discord, twitch_url, twitter_id")
    .eq("id", leagueData.league_id)
    .maybeSingle();
  leagueInfo = info;
}

// Get league results/standings for this season (no limit - show all teams)
const { data: standings } = await supa((Astro.locals as any).runtime)
  .from("league_results")
  .select("*")
  .eq("season_id", seasonId)
  .order("wins", { ascending: false });

// Tier is already in league_season_performance_mart
const leagueTier = leagueData?.league_tier || null;

// Tier badge colors to match tournaments
const tierColors: Record<string, string> = {
  'T1': 'bg-purple-900 text-purple-300 border-purple-500',
  'T2': 'bg-blue-900 text-blue-300 border-blue-500',
  'T3': 'bg-green-900 text-green-300 border-green-500',
  'T4': 'bg-yellow-900 text-yellow-300 border-yellow-500',
  'T5': 'bg-gray-900 text-gray-300 border-gray-500',
};

// Fetch conferences for this season
const { data: conferences } = await supa((Astro.locals as any).runtime)
  .from("lg_conf")
  .select("*")
  .eq("season", seasonId)
  .order("name", { ascending: true });

// Fetch divisions for this season
const { data: divisions } = await supa((Astro.locals as any).runtime)
  .from("lg_divisions")
  .select("*")
  .eq("season_id", seasonId)
  .order("display_order", { ascending: true });

// Fetch division-conference relationships
const { data: divisionConferences } = await supa((Astro.locals as any).runtime)
  .from("lg_division_conferences")
  .select("*");

// Fetch teams data separately and merge with standings
let teamsWithData = standings ?? [];
if (standings && standings.length > 0) {
  const teamIds = standings.map((s: any) => s.team_id).filter(Boolean);
  if (teamIds.length > 0) {
    const { data: teamsData } = await supa((Astro.locals as any).runtime)
      .from("teams")
      .select("id, global_rank, hybrid_score, leaderboard_tier, lg_conf")
      .in("id", teamIds);
    
    // Merge teams data with standings, conference info, and division info
    teamsWithData = standings.map((standing: any) => {
      const teamData = teamsData?.find((t: any) => t.id === standing.team_id);
      const conference = teamData?.lg_conf ? conferences?.find((c: any) => c.id === teamData.lg_conf) : null;
      
      // Find division by looking up which division this conference belongs to via junction table
      const divisionLink = conference ? divisionConferences?.find((dc: any) => dc.conference_id === conference.id) : null;
      const division = divisionLink ? divisions?.find((d: any) => d.id === divisionLink.division_id) : null;
      
      return {
        ...standing,
        teams: teamData,
        conference: conference ? {
          id: conference.id,
          name: conference.name,
          abbr: conference.abbr,
          conf_logo: conference.conf_logo
        } : null,
        division: division ? {
          id: division.id,
          name: division.name,
          abbr: division.abbr,
          division_logo: division.division_logo,
          display_order: division.display_order
        } : null
      };
    });
  }
}

// Get matches for this season (paginated in tabs, showing up to 100 matches)
// Use primary_season_id to include matches added via match_contexts
const { data: matchesData } = await supa((Astro.locals as any).runtime)
  .from("v_matches_with_primary_context")
  .select("id, played_at, team_a_id, team_b_id, score_a, score_b, stage, boxscore_url, status, verified, league_id, season_id, tournament_id, primary_season_id")
  .eq("primary_season_id", seasonId)
  .order("played_at", { ascending: false })
  .limit(1000);

// Get the last match update time for the notice
const lastMatchUpdate = matchesData && matchesData.length > 0 ? matchesData[0].played_at : null;

// Get team names separately
const teamIds = Array.from(new Set([
  ...(matchesData ?? []).map((m: any) => m.team_a_id),
  ...(matchesData ?? []).map((m: any) => m.team_b_id)
].filter(Boolean)));

const { data: teamsData } = teamIds.length > 0 ? await supa((Astro.locals as any).runtime)
  .from("teams")
  .select("id, name, logo_url")
  .in("id", teamIds) : { data: [] };

const teamMap = new Map((teamsData ?? []).map((t: any) => [t.id, t]));

// Get league info (use season_id for accurate season lookup)
const matchSeasonIds = Array.from(new Set((matchesData ?? []).map((m: any) => m.season_id).filter(Boolean)));
const { data: matchLeaguesData } = matchSeasonIds.length > 0 ? await supa((Astro.locals as any).runtime)
  .from("league_calendar")
  .select("season_id, league_id, league_name, season_number")
  .in("season_id", matchSeasonIds) : { data: [] };

const matchLeagueMap = new Map((matchLeaguesData ?? []).map((l: any) => [l.season_id, l]));

// Combine match data with team info
const matches = (matchesData ?? []).map((m: any) => ({
  ...m,
  team_a: teamMap.get(m.team_a_id),
  team_b: teamMap.get(m.team_b_id),
  league: matchLeagueMap.get(m.season_id),
}));

// Get player statistics from player_league_season_stats_mart
const { data: playerStats } = await supa((Astro.locals as any).runtime)
  .from("player_league_season_stats_mart")
  .select("player_id, gamertag, ppg, apg, rpg, spg, bpg, tpg, games_played, fg_pct, three_pt_pct, ft_pct, avg_performance_score, total_points, total_assists, total_rebounds, total_steals, total_blocks, total_turnovers")
  .eq("season_id", seasonId)
  .gte("games_played", 3);

const topScorers = (playerStats ?? [])
  .sort((a: any, b: any) => parseFloat(b.ppg) - parseFloat(a.ppg))
  .slice(0, 5)
  .map((p: any) => ({
    player_name: p.gamertag,
    points_per_game: parseFloat(p.ppg),
    games_played: p.games_played
  }));

const topAssists = (playerStats ?? [])
  .sort((a: any, b: any) => parseFloat(b.apg) - parseFloat(a.apg))
  .slice(0, 5)
  .map((p: any) => ({
    player_name: p.gamertag,
    assists_per_game: parseFloat(p.apg),
    games_played: p.games_played
  }));

const topRebounders = (playerStats ?? [])
  .sort((a: any, b: any) => parseFloat(b.rpg) - parseFloat(a.rpg))
  .slice(0, 5)
  .map((p: any) => ({
    player_name: p.gamertag,
    rebounds_per_game: parseFloat(p.rpg),
    games_played: p.games_played
  }));

const topSteals = (playerStats ?? [])
  .sort((a: any, b: any) => parseFloat(b.spg) - parseFloat(a.spg))
  .slice(0, 5)
  .map((p: any) => ({
    player_name: p.gamertag,
    steals_per_game: parseFloat(p.spg),
    games_played: p.games_played
  }));

const topBlocks = (playerStats ?? [])
  .sort((a: any, b: any) => parseFloat(b.bpg) - parseFloat(a.bpg))
  .slice(0, 5)
  .map((p: any) => ({
    player_name: p.gamertag,
    blocks_per_game: parseFloat(p.bpg),
    games_played: p.games_played
  }));

// Get full player statistics for league statistics tab from player_league_season_stats_mart
const { data: fullPlayerStatsRaw } = await supa((Astro.locals as any).runtime)
  .from("player_league_season_stats_mart")
  .select("*")
  .eq("season_id", seasonId)
  .gte("games_played", 1)
  .order("ppg", { ascending: false});

// Map mart fields to expected component fields
const fullPlayerStats = (fullPlayerStatsRaw ?? []).map((p: any) => ({
  player_id: p.player_id,
  player_gamertag: p.gamertag,
  games_played: p.games_played,
  points: p.total_points,
  rebounds: p.total_rebounds,
  assists: p.total_assists,
  steals: p.total_steals,
  blocks: p.total_blocks,
  turnovers: p.total_turnovers || 0,
  fouls: 0, // Not available in mart
  fgm: 0, // Not available in mart
  fga: 0, // Not available in mart
  ftm: 0, // Not available in mart
  fta: 0, // Not available in mart
  three_points_made: 0, // Not available in mart
  three_points_attempted: 0, // Not available in mart
  plus_minus: 0,
  performance_score: parseFloat(p.avg_performance_score) || 0,
  avg_points: parseFloat(p.ppg),
  avg_rebounds: parseFloat(p.rpg),
  avg_assists: parseFloat(p.apg),
  avg_steals: parseFloat(p.spg),
  avg_blocks: parseFloat(p.bpg),
  avg_turnovers: parseFloat(p.tpg) || 0,
  avg_fouls: 0, // Not available in mart
  fg_pct: p.fg_pct ? parseFloat(p.fg_pct) : null,
  three_pt_pct: p.three_pt_pct ? parseFloat(p.three_pt_pct) : null,
  ft_pct: p.ft_pct ? parseFloat(p.ft_pct) : null,
}));

// Get Regular Season player statistics (excluding tournament matches)
const { data: regularSeasonStatsRaw } = await supa((Astro.locals as any).runtime)
  .from("player_league_season_stats_mart")
  .select("*")
  .eq("season_id", seasonId)
  .order("ppg", { ascending: false });

const regularSeasonPlayerStats = (regularSeasonStatsRaw ?? []).map((p: any) => ({
  player_id: p.player_id,
  player_gamertag: p.gamertag,
  games_played: p.games_played,
  points: p.total_points,
  rebounds: p.total_rebounds,
  assists: p.total_assists,
  steals: p.total_steals,
  blocks: p.total_blocks,
  turnovers: p.total_turnovers || 0,
  fouls: 0, // Not available in player_league_season_stats_mart
  fgm: 0, // Not available in player_league_season_stats_mart
  fga: 0, // Not available in player_league_season_stats_mart
  ftm: 0, // Not available in player_league_season_stats_mart
  fta: 0, // Not available in player_league_season_stats_mart
  three_points_made: 0, // Not available in player_league_season_stats_mart
  three_points_attempted: 0, // Not available in player_league_season_stats_mart
  plus_minus: 0, // Not available in player_league_season_stats_mart
  performance_score: parseFloat(p.avg_performance_score) || 0,
  avg_points: parseFloat(p.ppg) || 0,
  avg_rebounds: parseFloat(p.rpg) || 0,
  avg_assists: parseFloat(p.apg) || 0,
  avg_steals: parseFloat(p.spg) || 0,
  avg_blocks: parseFloat(p.bpg) || 0,
  avg_turnovers: parseFloat(p.tpg) || 0,
  avg_fouls: 0, // Not available in player_league_season_stats_mart
  fg_pct: p.fg_pct,
  three_pt_pct: p.three_pt_pct,
  ft_pct: p.ft_pct,
}));

// Get Open Tournament player statistics
const { data: openStatsRaw } = await supa((Astro.locals as any).runtime)
  .from("league_open_player_stats")
  .select("*")
  .eq("season_id", seasonId)
  .order("avg_points", { ascending: false });

const openPlayerStats = (openStatsRaw ?? []).map((p: any) => ({
  player_id: p.player_id,
  player_gamertag: p.gamertag,
  games_played: p.games_played,
  points: p.total_points,
  rebounds: p.total_rebounds,
  assists: p.total_assists,
  steals: p.total_steals,
  blocks: p.total_blocks,
  turnovers: p.total_turnovers || 0,
  fouls: p.total_fouls || 0,
  fgm: p.total_fgm || 0,
  fga: p.total_fga || 0,
  ftm: p.total_ftm || 0,
  fta: p.total_fta || 0,
  three_points_made: p.total_3pm || 0,
  three_points_attempted: p.total_3pa || 0,
  plus_minus: p.total_plus_minus || 0,
  performance_score: parseFloat(p.avg_performance_score) || 0,
  avg_points: parseFloat(p.avg_points) || 0,
  avg_rebounds: parseFloat(p.avg_rebounds) || 0,
  avg_assists: parseFloat(p.avg_assists) || 0,
  avg_steals: parseFloat(p.avg_steals) || 0,
  avg_blocks: parseFloat(p.avg_blocks) || 0,
  avg_turnovers: parseFloat(p.avg_turnovers) || 0,
  avg_fouls: parseFloat(p.avg_fouls) || 0,
  fg_pct: p.fg_pct,
  three_pt_pct: p.three_pt_pct,
  ft_pct: p.ft_pct,
}));

// Get Playoff Tournament player statistics
const { data: playoffStatsRaw } = await supa((Astro.locals as any).runtime)
  .from("league_playoff_player_stats")
  .select("*")
  .eq("season_id", seasonId)
  .order("avg_points", { ascending: false });

const playoffPlayerStats = (playoffStatsRaw ?? []).map((p: any) => ({
  player_id: p.player_id,
  player_gamertag: p.gamertag,
  games_played: p.games_played,
  points: p.total_points,
  rebounds: p.total_rebounds,
  assists: p.total_assists,
  steals: p.total_steals,
  blocks: p.total_blocks,
  turnovers: p.total_turnovers || 0,
  fouls: p.total_fouls || 0,
  fgm: p.total_fgm || 0,
  fga: p.total_fga || 0,
  ftm: p.total_ftm || 0,
  fta: p.total_fta || 0,
  three_points_made: p.total_3pm || 0,
  three_points_attempted: p.total_3pa || 0,
  plus_minus: p.total_plus_minus || 0,
  performance_score: parseFloat(p.avg_performance_score) || 0,
  avg_points: parseFloat(p.avg_points) || 0,
  avg_rebounds: parseFloat(p.avg_rebounds) || 0,
  avg_assists: parseFloat(p.avg_assists) || 0,
  avg_steals: parseFloat(p.avg_steals) || 0,
  avg_blocks: parseFloat(p.avg_blocks) || 0,
  avg_turnovers: parseFloat(p.avg_turnovers) || 0,
  avg_fouls: parseFloat(p.avg_fouls) || 0,
  fg_pct: p.fg_pct,
  three_pt_pct: p.three_pt_pct,
  ft_pct: p.ft_pct,
}));

// Fetch Open Tournament data
let openTournament = null;
const { data: openTournamentData } = await supa((Astro.locals as any).runtime)
  .from("league_open")
  .select("open_champion, open_prize, status, start_date, finals_date, tournament_type, series_format")
  .eq("season_id", seasonId)
  .maybeSingle();

if (openTournamentData) {
  // Fetch open tournament matches
  const { data: openMatchesData } = await supa((Astro.locals as any).runtime)
    .from("league_open_matches")
    .select("match_id, stage, series_number")
    .eq("season_id", seasonId);

  // Fetch series formats for open tournament
  const { data: openSeriesFormats } = await supa((Astro.locals as any).runtime)
    .from("series_formats")
    .select("stage, series_format")
    .eq("season_id", seasonId)
    .eq("tournament_type", "open");

  // Get match details for open tournament
  const openMatchIds = (openMatchesData ?? []).map((m: any) => m.match_id).filter(Boolean);
  let openMatches: any[] = [];
  
  if (openMatchIds.length > 0) {
    const { data: openMatchDetails } = await supa((Astro.locals as any).runtime)
      .from("v_matches_with_primary_context")
      .select("id, played_at, team_a_id, team_b_id, score_a, score_b, winner_id")
      .in("id", openMatchIds);

    // Get team data for tournament teams (they might not be in season matches)
    const tournamentTeamIds = Array.from(new Set([
      ...(openMatchDetails ?? []).map((m: any) => m.team_a_id),
      ...(openMatchDetails ?? []).map((m: any) => m.team_b_id)
    ].filter(Boolean)));

    const { data: tournamentTeamsData } = tournamentTeamIds.length > 0 ? await supa((Astro.locals as any).runtime)
      .from("teams")
      .select("id, name, logo_url")
      .in("id", tournamentTeamIds) : { data: [] };

    // Add tournament teams to teamMap
    (tournamentTeamsData ?? []).forEach((t: any) => {
      if (!teamMap.has(t.id)) {
        teamMap.set(t.id, t);
      }
    });

    // Create series format lookup map
    const seriesFormatMap = new Map(
      (openSeriesFormats ?? []).map((sf: any) => [sf.stage, sf.series_format])
    );

    // Combine match details with stage/series info and team data
    openMatches = (openMatchDetails ?? []).map((match: any) => {
      const matchInfo = openMatchesData?.find((m: any) => m.match_id === match.id);
      const stage = matchInfo?.stage ?? null;
      return {
        ...match,
        stage: stage,
        series_number: matchInfo?.series_number ?? null,
        series_format: seriesFormatMap.get(stage) || 'bo1', // Default to BO1 if no format specified
        team_a: teamMap.get(match.team_a_id),
        team_b: teamMap.get(match.team_b_id),
      };
    });
  }

  openTournament = {
    champion: openTournamentData.open_champion,
    prize: openTournamentData.open_prize,
    status: openTournamentData.status,
    start_date: openTournamentData.start_date,
    finals_date: openTournamentData.finals_date,
    tournament_type: openTournamentData.tournament_type,
    series_format: openTournamentData.series_format,
    matches: openMatches,
  };
}

// Fetch Playoff Tournament data
let playoffTournament = null;
const { data: playoffTournamentData } = await supa((Astro.locals as any).runtime)
  .from("league_playoff")
  .select("playoff_champion, playoff_prize, status, start_date, finals_date, tournament_type, series_format")
  .eq("season_id", seasonId)
  .maybeSingle();

if (playoffTournamentData) {
  // Fetch playoff tournament matches
  const { data: playoffMatchesData } = await supa((Astro.locals as any).runtime)
    .from("league_playoff_matches")
    .select("match_id, stage, series_number")
    .eq("season_id", seasonId);

  // Fetch series formats for playoff tournament (same table, filtered by season_id and tournament_type)
  const { data: playoffSeriesFormats } = await supa((Astro.locals as any).runtime)
    .from("series_formats")
    .select("stage, series_format")
    .eq("season_id", seasonId)
    .eq("tournament_type", "playoff");

  // Get match details for playoff tournament
  const playoffMatchIds = (playoffMatchesData ?? []).map((m: any) => m.match_id).filter(Boolean);
  let playoffMatches: any[] = [];
  
  if (playoffMatchIds.length > 0) {
    const { data: playoffMatchDetails } = await supa((Astro.locals as any).runtime)
      .from("v_matches_with_primary_context")
      .select("id, played_at, team_a_id, team_b_id, score_a, score_b, winner_id")
      .in("id", playoffMatchIds);

    // Get team data for tournament teams (they might not be in season matches)
    const playoffTeamIds = Array.from(new Set([
      ...(playoffMatchDetails ?? []).map((m: any) => m.team_a_id),
      ...(playoffMatchDetails ?? []).map((m: any) => m.team_b_id)
    ].filter(Boolean)));

    const { data: playoffTeamsData } = playoffTeamIds.length > 0 ? await supa((Astro.locals as any).runtime)
      .from("teams")
      .select("id, name, logo_url")
      .in("id", playoffTeamIds) : { data: [] };

    // Add playoff tournament teams to teamMap
    (playoffTeamsData ?? []).forEach((t: any) => {
      if (!teamMap.has(t.id)) {
        teamMap.set(t.id, t);
      }
    });

    // Create series format lookup map for playoffs
    const playoffSeriesFormatMap = new Map(
      (playoffSeriesFormats ?? []).map((sf: any) => [sf.stage, sf.series_format])
    );

    // Combine match details with stage/series info and team data
    playoffMatches = (playoffMatchDetails ?? []).map((match: any) => {
      const matchInfo = playoffMatchesData?.find((m: any) => m.match_id === match.id);
      const stage = matchInfo?.stage ?? null;
      return {
        ...match,
        stage: stage,
        series_number: matchInfo?.series_number ?? null,
        series_format: playoffSeriesFormatMap.get(stage) || 'bo1', // Default to BO1 if no format specified
        team_a: teamMap.get(match.team_a_id),
        team_b: teamMap.get(match.team_b_id),
      };
    });
  }

  playoffTournament = {
    champion: playoffTournamentData.playoff_champion,
    prize: playoffTournamentData.playoff_prize,
    status: playoffTournamentData.status,
    start_date: playoffTournamentData.start_date,
    finals_date: playoffTournamentData.finals_date,
    tournament_type: playoffTournamentData.tournament_type,
    series_format: playoffTournamentData.series_format,
    matches: playoffMatches,
  };
}

const league = leagueData;
const teamStandings = teamsWithData ?? [];
const recentMatches = matches ?? [];

if (!league) {
  return Astro.redirect("/leagues");
}

// Prepare league info object for tabs (using data from league_season_performance_mart)
const leagueInfoForTabs = {
  league_name: league.league_name,
  season_number: league.season_number,
  game_year: league.game_year,
  start_date: null, // Not in mart
  end_date: null, // Not in mart
  is_active: league.is_active,
  entry_fee: entryFee,
  prize_pool: prizePool,
  tier: league.league_tier, // From mart
  lg_url: leagueInfo?.lg_url,
  lg_discord: leagueInfo?.lg_discord,
  twitch_url: leagueInfo?.twitch_url,
  twitter_id: leagueInfo?.twitter_id,
};
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{league.league_name} - Pro-Am Rankings</title>
  </head>
  <body class="bg-brand-navy text-white">
    <Navigation />
    <main class="mx-auto max-w-6xl p-6">
      <!-- League Header -->
      <div class="mb-8 flex items-start gap-6">
        {league.league_logo && (
          <img 
            src={league.league_logo}
            alt={league.league_name || "League"}
            class="h-24 w-24 rounded-lg"
          />
        )}
        <div class="flex-1">
          <h1 class="text-3xl font-bold mb-2">{league.league_name}</h1>
          <div class="flex flex-wrap gap-4 text-sm mb-3">
            {leagueTier && (
              <span class={`px-3 py-1 rounded text-sm font-bold border ${tierColors[leagueTier as string] || 'bg-gray-900 text-gray-300 border-gray-500'}`}>
                {leagueTier}
              </span>
            )}
            <div>
              <span class="text-neutral-400">Season:</span>
              <span class="ml-2 font-semibold">{league.season_number ?? '-'}</span>
            </div>
            <div>
              <span class="text-neutral-400">Year:</span>
              <span class="ml-2 font-semibold">{league.game_year ?? '-'}</span>
            </div>
            {entryFee && (
              <div>
                <span class="text-neutral-400">Entry Fee:</span>
                <span class="ml-2 font-semibold">${entryFee}</span>
              </div>
            )}
            {prizePool && (
              <div>
                <span class="text-neutral-400">Prize Pool:</span>
                <span class="ml-2 font-semibold text-green-400">${prizePool}</span>
              </div>
            )}
            {league.is_active && (
              <span class="px-2 py-1 rounded text-xs font-bold bg-green-900 text-green-300">Active</span>
            )}
          </div>
          {leagueInfo && (
            <div class="flex flex-wrap gap-2 text-sm">
              {leagueInfo.lg_url && (
                <a href={leagueInfo.lg_url} target="_blank" rel="noopener noreferrer" class="px-3 py-1 rounded bg-neutral-800 hover:bg-neutral-700 transition">
                  üåê Website
                </a>
              )}
              {leagueInfo.lg_discord && (
                <a href={leagueInfo.lg_discord} target="_blank" rel="noopener noreferrer" class="px-3 py-1 rounded bg-indigo-900 hover:bg-indigo-800 transition">
                  üí¨ Discord
                </a>
              )}
              {leagueInfo.twitch_url && (
                <a href={leagueInfo.twitch_url} target="_blank" rel="noopener noreferrer" class="px-3 py-1 rounded bg-purple-900 hover:bg-purple-800 transition">
                  üì∫ Twitch
                </a>
              )}
              {leagueInfo.twitter_id && (
                <a href={`https://twitter.com/${leagueInfo.twitter_id}`} target="_blank" rel="noopener noreferrer" class="px-3 py-1 rounded bg-sky-900 hover:bg-sky-800 transition">
                  üê¶ Twitter
                </a>
              )}
            </div>
          )}
        </div>
      </div>

      <!-- Last Updated Notice -->
      {lastMatchUpdate && (
        <div class="mb-4 p-3 rounded-lg border border-neutral-700 bg-neutral-800/50">
          <div class="flex items-center gap-2 text-sm text-neutral-300">
            <svg class="w-4 h-4 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>
              Last match: <span class="font-medium text-white">{new Date(lastMatchUpdate).toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
              })}</span>
            </span>
          </div>
        </div>
      )}

      <!-- Verification Info Notice -->
      <div class="mb-6 p-4 rounded-lg border border-blue-500/30 bg-blue-900/10">
        <div class="flex items-start gap-3">
          <svg class="w-5 h-5 text-blue-400 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
          </svg>
          <div class="flex-1">
            <h3 class="text-sm font-semibold text-blue-300 mb-1">About Match Verification</h3>
            <p class="text-sm text-neutral-300">
              Unless a match has the <span class="text-green-300 font-medium">Verified</span> badge, stats were derived from OCR (Optical Character Recognition) and may contain errors. 
              Only verified stats are entered into our statistics tables and affect player ratings. 
              <a href="/ranking-system#verification" class="text-blue-400 hover:text-blue-300 underline">Learn more</a>
            </p>
          </div>
        </div>
      </div>

      <!-- League Tabs -->
      <LeagueTabsIsland 
        client:load
        standings={teamStandings as any}
        matches={recentMatches as any}
        topScorers={topScorers as any}
        topAssists={topAssists as any}
        topRebounders={topRebounders as any}
        topSteals={topSteals as any}
        topBlocks={topBlocks as any}
        leagueInfo={leagueInfoForTabs as any}
        playerStats={fullPlayerStats as any}
        regularSeasonPlayerStats={regularSeasonPlayerStats as any}
        openPlayerStats={openPlayerStats as any}
        playoffPlayerStats={playoffPlayerStats as any}
        openTournament={openTournament as any}
        playoffTournament={playoffTournament as any}
        conferences={conferences as any}
        divisions={divisions as any}
        divisionConferences={divisionConferences as any}
      />
    </main>
  </body>
</html>

