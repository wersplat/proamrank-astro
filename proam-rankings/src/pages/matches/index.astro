---
import BaseLayout from "../../components/BaseLayout.astro";
import Navigation from "../../components/Navigation.astro";
import MatchesListIsland from "../../components/MatchesListIsland";
import { supa } from "../../lib/supabase";
import "../../styles/global.css";
import { buildFilterQuery, hasActiveFilters } from "../../lib/filterUtils";

const MATCHES_PER_PAGE = 25;

// Get page from URL params
const currentPage = parseInt(Astro.url.searchParams.get('page') || '1', 10);
const offset = (currentPage - 1) * MATCHES_PER_PAGE;

// Get filter parameters
const leagueFilter = Astro.url.searchParams.get('league') || 'all';
const tournamentFilter = Astro.url.searchParams.get('tournament') || 'all';
const teamFilter = Astro.url.searchParams.get('team') || 'all';
const yearFilter = Astro.url.searchParams.get('year') || 'all';
const verifiedFilter = Astro.url.searchParams.get('verified') || 'all';
const stageFilter = Astro.url.searchParams.get('stage') || 'all';
const playerSearch = Astro.url.searchParams.get('player') || '';

// Use match_analytics_mart for verified matches only (since mart only contains verified matches)
// Fall back to v_matches_with_primary_context for unverified/review filters or when player search is used
const useMart = (verifiedFilter === 'all' || verifiedFilter === 'verified') && !playerSearch;

let matchesData, error, count;

if (useMart) {
  // Use optimized mart for verified matches
  let countQuery = supa((Astro.locals as any).runtime)
    .from("match_analytics_mart")
    .select("*", { count: 'exact', head: true });

  if (leagueFilter !== 'all') {
    countQuery = countQuery.contains("season_ids", [leagueFilter]);
  }

  if (tournamentFilter !== 'all') {
    countQuery = countQuery.contains("tournament_ids", [tournamentFilter]);
  }

  if (teamFilter !== 'all') {
    countQuery = countQuery.or(`team_a_id.eq.${teamFilter},team_b_id.eq.${teamFilter}`);
  }

  if (yearFilter !== 'all') {
    countQuery = countQuery.eq("game_year", yearFilter as any);
  }

  if (stageFilter !== 'all') {
    countQuery = countQuery.eq("stage", stageFilter as any);
  }

  const countResult = await countQuery;
  count = countResult.count;

  // Build data query with same filters
  let dataQuery = supa((Astro.locals as any).runtime)
    .from("match_analytics_mart")
    .select("*");

  if (leagueFilter !== 'all') {
    dataQuery = dataQuery.contains("season_ids", [leagueFilter]);
  }

  if (tournamentFilter !== 'all') {
    dataQuery = dataQuery.contains("tournament_ids", [tournamentFilter]);
  }

  if (teamFilter !== 'all') {
    dataQuery = dataQuery.or(`team_a_id.eq.${teamFilter},team_b_id.eq.${teamFilter}`);
  }

  if (yearFilter !== 'all') {
    dataQuery = dataQuery.eq("game_year", yearFilter as any);
  }

  if (stageFilter !== 'all') {
    dataQuery = dataQuery.eq("stage", stageFilter as any);
  }

  const result = await dataQuery
    .order("played_at", { ascending: false })
    .range(offset, offset + MATCHES_PER_PAGE - 1);

  matchesData = result.data;
  error = result.error;
} else {
  // Fall back to v_matches_with_primary_context for unverified/review matches or player search
  // Handle player search - get match IDs where player participated
  let playerMatchIds: string[] = [];
  if (playerSearch) {
    const { data: playerStatsData } = await supa((Astro.locals as any).runtime)
      .from("player_stats")
      .select("match_id")
      .ilike("player_name", `%${playerSearch}%`);
    
    playerMatchIds = Array.from(new Set((playerStatsData ?? []).map((ps: any) => ps.match_id)));
  }

  let countQuery = supa((Astro.locals as any).runtime)
    .from("v_matches_with_primary_context")
    .select("*", { count: 'exact', head: true });

  if (leagueFilter !== 'all') {
    countQuery = countQuery.eq("season_id", leagueFilter);
  }

  if (tournamentFilter !== 'all') {
    countQuery = countQuery.eq("tournament_id", tournamentFilter);
  }

  if (teamFilter !== 'all') {
    countQuery = countQuery.or(`team_a_id.eq.${teamFilter},team_b_id.eq.${teamFilter}`);
  }

  if (yearFilter !== 'all') {
    countQuery = countQuery.eq("game_year", yearFilter as any);
  }

  if (verifiedFilter === 'verified') {
    countQuery = countQuery.eq("verified", true);
  } else if (verifiedFilter === 'review') {
    countQuery = countQuery.eq("verified", false).eq("status", "processed");
  } else if (verifiedFilter === 'unverified') {
    countQuery = countQuery.is("verified", null);
  }

  if (stageFilter !== 'all') {
    countQuery = countQuery.eq("stage", stageFilter as any);
  }

  if (playerSearch && playerMatchIds.length > 0) {
    countQuery = countQuery.in("id", playerMatchIds);
  } else if (playerSearch && playerMatchIds.length === 0) {
    countQuery = countQuery.eq("id", "00000000-0000-0000-0000-000000000000");
  }

  const countResult = await countQuery;
  count = countResult.count;

  // Build data query with same filters
  let dataQuery = supa((Astro.locals as any).runtime)
    .from("v_matches_with_primary_context")
    .select("id, played_at, team_a_id, team_b_id, score_a, score_b, stage, game_year, boxscore_url, status, verified, league_id, season_id, tournament_id");

  if (leagueFilter !== 'all') {
    dataQuery = dataQuery.eq("season_id", leagueFilter);
  }

  if (tournamentFilter !== 'all') {
    dataQuery = dataQuery.eq("tournament_id", tournamentFilter);
  }

  if (teamFilter !== 'all') {
    dataQuery = dataQuery.or(`team_a_id.eq.${teamFilter},team_b_id.eq.${teamFilter}`);
  }

  if (yearFilter !== 'all') {
    dataQuery = dataQuery.eq("game_year", yearFilter as any);
  }

  if (verifiedFilter === 'verified') {
    dataQuery = dataQuery.eq("verified", true);
  } else if (verifiedFilter === 'review') {
    dataQuery = dataQuery.eq("verified", false).eq("status", "processed");
  } else if (verifiedFilter === 'unverified') {
    dataQuery = dataQuery.is("verified", null);
  }

  if (stageFilter !== 'all') {
    dataQuery = dataQuery.eq("stage", stageFilter as any);
  }

  if (playerSearch && playerMatchIds.length > 0) {
    dataQuery = dataQuery.in("id", playerMatchIds);
  } else if (playerSearch && playerMatchIds.length === 0) {
    dataQuery = dataQuery.eq("id", "00000000-0000-0000-0000-000000000000");
  }

  const result = await dataQuery
    .order("played_at", { ascending: false })
    .range(offset, offset + MATCHES_PER_PAGE - 1);

  matchesData = result.data;
  error = result.error;
}

const totalPages = Math.ceil((count || 0) / MATCHES_PER_PAGE);

if (error) console.error(error);

let matches;

if (useMart) {
  // Map match_analytics_mart to expected format
  matches = (matchesData ?? []).map((m: any) => ({
    id: m.match_id,
    played_at: m.played_at,
    team_a_id: m.team_a_id,
    team_b_id: m.team_b_id,
    score_a: m.score_a,
    score_b: m.score_b,
    stage: m.stage,
    game_year: m.game_year,
    boxscore_url: m.boxscore_url,
    status: 'verified',
    verified: true, // All matches in mart are verified
    team_a: {
      id: m.team_a_id,
      name: m.team_a_name,
      logo_url: m.team_a_logo,
    },
    team_b: {
      id: m.team_b_id,
      name: m.team_b_name,
      logo_url: m.team_b_logo,
    },
    league: m.league_name ? {
      season_id: m.season_ids?.[0],
      league_name: m.league_name,
      season_number: null,
    } : null,
    tournament: m.tournament_name ? {
      id: m.tournament_ids?.[0],
      name: m.tournament_name,
    } : null,
  }));
} else {
  // Map v_matches_with_primary_context to expected format
  // Get team info
  const teamIds = Array.from(new Set([
    ...(matchesData ?? []).map((m: any) => m.team_a_id),
    ...(matchesData ?? []).map((m: any) => m.team_b_id)
  ].filter(Boolean)));

  const { data: matchTeamsData } = teamIds.length > 0 ? await supa((Astro.locals as any).runtime)
    .from("teams")
    .select("id, name, logo_url")
    .in("id", teamIds) : { data: [] };

  const teamMap = new Map((matchTeamsData ?? []).map((t: any) => [t.id, t]));

  // Get league info (use season_id for accurate season lookup)
  const seasonIds = Array.from(new Set((matchesData ?? []).map((m: any) => m.season_id).filter(Boolean)));
  const { data: matchLeaguesData } = seasonIds.length > 0 ? await supa((Astro.locals as any).runtime)
    .from("league_calendar")
    .select("season_id, league_id, league_name, season_number")
    .in("season_id", seasonIds) : { data: [] };

  const leagueMap = new Map((matchLeaguesData ?? []).map((l: any) => [l.season_id, l]));

  // Get tournament info
  const tournamentIds = Array.from(new Set((matchesData ?? []).map((m: any) => m.tournament_id).filter(Boolean)));
  const { data: matchTournamentsData } = tournamentIds.length > 0 ? await supa((Astro.locals as any).runtime)
    .from("tournaments")
    .select("id, name")
    .in("id", tournamentIds) : { data: [] };

  const tournamentMap = new Map((matchTournamentsData ?? []).map((t: any) => [t.id, t]));

  // Combine all data
  matches = (matchesData ?? []).map((m: any) => ({
    id: m.id,
    played_at: m.played_at,
    team_a_id: m.team_a_id,
    team_b_id: m.team_b_id,
    score_a: m.score_a,
    score_b: m.score_b,
    stage: m.stage,
    game_year: m.game_year,
    boxscore_url: m.boxscore_url,
    status: m.status,
    verified: m.verified,
    team_a: teamMap.get(m.team_a_id),
    team_b: teamMap.get(m.team_b_id),
    league: leagueMap.get(m.season_id),
    tournament: tournamentMap.get(m.tournament_id),
  }));
}

// Generate page numbers for pagination
function getPageNumbers(current: number, total: number): number[] {
  const maxVisible = Math.min(7, total);
  const pages: number[] = [];
  
  if (total <= 7) {
    for (let i = 1; i <= total; i++) pages.push(i);
  } else if (current <= 4) {
    for (let i = 1; i <= 7; i++) pages.push(i);
  } else if (current >= total - 3) {
    for (let i = total - 6; i <= total; i++) pages.push(i);
  } else {
    for (let i = current - 3; i <= current + 3; i++) pages.push(i);
  }
  
  return pages;
}

const pageNumbers = getPageNumbers(currentPage, totalPages);

// Fetch filter options
// Get available leagues/seasons from league_season_performance_mart
const { data: filterLeaguesData } = await supa((Astro.locals as any).runtime)
  .from("league_season_performance_mart")
  .select("season_id, league_name, season_number")
  .order("league_name", { ascending: true });

const leagueOptions = (filterLeaguesData ?? []).map((l: any) => ({
  value: l.season_id,
  label: `${l.league_name}${l.season_number ? ` S${l.season_number}` : ''}`
}));

// Get available tournaments from tournament_performance_mart
const { data: filterTournamentsData } = await supa((Astro.locals as any).runtime)
  .from("tournament_performance_mart")
  .select("tournament_id, tournament_name")
  .order("tournament_name", { ascending: true });

const tournamentOptions = (filterTournamentsData ?? []).map((t: any) => ({
  value: t.tournament_id,
  label: t.tournament_name
}));

// Get available teams from team_analytics_mart
const { data: filterTeamsData } = await supa((Astro.locals as any).runtime)
  .from("team_analytics_mart")
  .select("team_id, team_name")
  .order("team_name", { ascending: true });

const teamOptions = (filterTeamsData ?? []).map((t: any) => ({
  value: t.team_id,
  label: t.team_name
}));

// Get available years from match_analytics_mart
const { data: yearsData } = await supa((Astro.locals as any).runtime)
  .from("match_analytics_mart")
  .select("game_year")
  .not("game_year", "is", null);

const uniqueYears = [...new Set((yearsData ?? []).map((y: any) => y.game_year))].filter(Boolean).sort().reverse();

// Get available stages from match_analytics_mart
const { data: stagesData } = await supa((Astro.locals as any).runtime)
  .from("match_analytics_mart")
  .select("stage")
  .not("stage", "is", null);

const uniqueStages = [...new Set((stagesData ?? []).map((s: any) => s.stage))].filter(Boolean).sort();

// Build filter query for pagination links
const filterQuery = buildFilterQuery({
  league: leagueFilter,
  tournament: tournamentFilter,
  team: teamFilter,
  year: yearFilter,
  verified: verifiedFilter,
  stage: stageFilter,
  player: playerSearch
});

// Check if filters are active
const filtersActive = hasActiveFilters(
  { league: leagueFilter, tournament: tournamentFilter, team: teamFilter, year: yearFilter, verified: verifiedFilter, stage: stageFilter, player: playerSearch },
  { league: 'all', tournament: 'all', team: 'all', year: 'all', verified: 'all', stage: 'all', player: '' }
);
---

<BaseLayout 
  title="Matches"
  description="Review match results, boxscores, and statistics from NBA 2K Pro-Am games. View detailed game logs and player performance data"
>
  <Navigation />
    <main class="mx-auto max-w-6xl p-6 logo-underlay" style={`--logo-url: url('/GR.svg')`}>
      <div class="mb-6">
        <div class="flex items-center justify-between mb-4">
          <h1 class="text-2xl font-bold text-gray-900 dark:text-white">Recent Matches</h1>
          <div class="text-sm text-gray-600 dark:text-neutral-400">
            Page {currentPage} of {totalPages} • {count || 0} total matches
          </div>
        </div>

        <!-- Filters -->
        <div class="flex flex-wrap gap-3 mb-4">
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">Player:</label>
            <input
              type="text"
              id="playerInput"
              placeholder="Player name..."
              value={playerSearch}
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm w-48"
              onkeydown="if (event.key === 'Enter') window.location.href = updateFilter('player', this.value)"
            />
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">League:</label>
            <select 
              id="leagueFilter"
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm max-w-[200px]"
              onchange="window.location.href = updateFilter('league', this.value)"
            >
              <option value="all" selected={leagueFilter === 'all'}>All Leagues</option>
              {leagueOptions.map((league) => (
                <option value={league.value} selected={leagueFilter === league.value}>{league.label}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">Tournament:</label>
            <select 
              id="tournamentFilter"
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm max-w-[200px]"
              onchange="window.location.href = updateFilter('tournament', this.value)"
            >
              <option value="all" selected={tournamentFilter === 'all'}>All Tournaments</option>
              {tournamentOptions.map((tournament) => (
                <option value={tournament.value} selected={tournamentFilter === tournament.value}>{tournament.label}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">Team:</label>
            <select 
              id="teamFilter"
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm max-w-[200px]"
              onchange="window.location.href = updateFilter('team', this.value)"
            >
              <option value="all" selected={teamFilter === 'all'}>All Teams</option>
              {teamOptions.map((team) => (
                <option value={team.value} selected={teamFilter === team.value}>{team.label}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">Year:</label>
            <select 
              id="yearFilter"
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm"
              onchange="window.location.href = updateFilter('year', this.value)"
            >
              <option value="all" selected={yearFilter === 'all'}>All Years</option>
              {uniqueYears.map((year: string) => (
                <option value={year} selected={yearFilter === year}>{year}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">Status:</label>
            <select 
              id="verifiedFilter"
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm"
              onchange="window.location.href = updateFilter('verified', this.value)"
            >
              <option value="all" selected={verifiedFilter === 'all'}>All</option>
              <option value="verified" selected={verifiedFilter === 'verified'}>Verified</option>
              <option value="review" selected={verifiedFilter === 'review'}>Under Review</option>
              <option value="unverified" selected={verifiedFilter === 'unverified'}>Unverified</option>
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-700 dark:text-neutral-400">Stage:</label>
            <select 
              id="stageFilter"
              class="px-3 py-1 rounded bg-white dark:bg-neutral-800 border border-gray-300 dark:border-neutral-700 text-gray-900 dark:text-white text-sm"
              onchange="window.location.href = updateFilter('stage', this.value)"
            >
              <option value="all" selected={stageFilter === 'all'}>All Stages</option>
              {uniqueStages.map((stage: string) => (
                <option value={stage} selected={stageFilter === stage}>{stage}</option>
              ))}
            </select>
          </div>

          {filtersActive && (
            <a 
              href="/matches" 
              class="px-3 py-1 rounded bg-gray-200 dark:bg-neutral-800 hover:bg-gray-300 dark:hover:bg-neutral-700 transition text-sm text-gray-900 dark:text-white"
            >
              Clear Filters
            </a>
          )}
        </div>
      </div>

      <script is:inline>
        function updateFilter(param, value) {
          const url = new URL(window.location.href);
          if (value === 'all' || (param === 'player' && value === '')) {
            url.searchParams.delete(param);
          } else {
            url.searchParams.set(param, value);
          }
          url.searchParams.delete('page'); // Reset to page 1 when filtering
          return url.toString();
        }
      </script>

      <!-- Verification Info Notice -->
      <div class="mb-6 p-4 rounded-lg border border-blue-500/30 dark:border-blue-500/30 bg-blue-50 dark:bg-blue-900/10">
        <div class="flex items-start gap-3">
          <svg class="w-5 h-5 text-blue-600 dark:text-blue-400 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
          </svg>
          <div class="flex-1">
            <h3 class="text-sm font-semibold text-blue-700 dark:text-blue-300 mb-1">About Match Verification</h3>
            <p class="text-sm text-gray-700 dark:text-neutral-300">
              Unless a match has the <span class="text-green-700 dark:text-green-300 font-medium">Verified</span> badge, stats were derived from OCR (Optical Character Recognition) and may contain errors. 
              Only verified stats are entered into our statistics tables and affect player ratings. 
              <a href="/ranking-system#verification" class="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 underline">Learn more</a>
            </p>
          </div>
        </div>
      </div>

      <!-- Interactive Matches List (Astro Island) -->
      <MatchesListIsland client:load matches={matches} />

      {matches.length === 0 && (
        <div class="text-center py-12 text-gray-600 dark:text-neutral-400">
          No matches found.
        </div>
      )}

      <!-- Pagination -->
      {totalPages > 1 && (
        <div class="mt-8 flex items-center justify-center gap-2">
          {/* Previous Button */}
          {currentPage > 1 ? (
            <a
              href={`/matches?page=${currentPage - 1}${filterQuery}`}
              class="px-4 py-2 rounded bg-gray-200 dark:bg-neutral-800 hover:bg-gray-300 dark:hover:bg-neutral-700 transition text-gray-900 dark:text-white"
            >
              ← Previous
            </a>
          ) : (
            <span class="px-4 py-2 rounded bg-gray-100 dark:bg-neutral-900 text-gray-400 dark:text-neutral-600 cursor-not-allowed">
              ← Previous
            </span>
          )}

          {/* Page Numbers */}
          <div class="flex gap-1">
            {pageNumbers.map((pageNum: number) => (
              <a
                href={`/matches?page=${pageNum}${filterQuery}`}
                class={`px-3 py-2 rounded transition ${
                  pageNum === currentPage
                    ? 'bg-blue-600 text-white font-semibold'
                    : 'bg-gray-200 dark:bg-neutral-800 hover:bg-gray-300 dark:hover:bg-neutral-700 text-gray-900 dark:text-white'
                }`}
              >
                {pageNum}
              </a>
            ))}
          </div>

          {/* Next Button */}
          {currentPage < totalPages ? (
            <a
              href={`/matches?page=${currentPage + 1}${filterQuery}`}
              class="px-4 py-2 rounded bg-gray-200 dark:bg-neutral-800 hover:bg-gray-300 dark:hover:bg-neutral-700 transition text-gray-900 dark:text-white"
            >
              Next →
            </a>
          ) : (
            <span class="px-4 py-2 rounded bg-gray-100 dark:bg-neutral-900 text-gray-400 dark:text-neutral-600 cursor-not-allowed">
              Next →
            </span>
          )}
        </div>
      )}
    </main>
</BaseLayout>

