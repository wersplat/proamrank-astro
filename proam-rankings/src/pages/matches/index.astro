---
import Navigation from "../../components/Navigation.astro";
import MatchesListIsland from "../../components/MatchesListIsland";
import { supa } from "../../lib/supabase";
import "../../styles/global.css";
import { buildFilterQuery, hasActiveFilters } from "../../lib/filterUtils";

const MATCHES_PER_PAGE = 25;

// Get page from URL params
const currentPage = parseInt(Astro.url.searchParams.get('page') || '1', 10);
const offset = (currentPage - 1) * MATCHES_PER_PAGE;

// Get filter parameters
const leagueFilter = Astro.url.searchParams.get('league') || 'all';
const tournamentFilter = Astro.url.searchParams.get('tournament') || 'all';
const teamFilter = Astro.url.searchParams.get('team') || 'all';
const yearFilter = Astro.url.searchParams.get('year') || 'all';
const verifiedFilter = Astro.url.searchParams.get('verified') || 'all';
const stageFilter = Astro.url.searchParams.get('stage') || 'all';
const playerSearch = Astro.url.searchParams.get('player') || '';

// Build query with filters - use match_analytics_mart for optimized performance
let countQuery = supa((Astro.locals as any).runtime)
  .from("match_analytics_mart")
  .select("*", { count: 'exact', head: true });

if (leagueFilter !== 'all') {
  countQuery = countQuery.contains("season_ids", [leagueFilter]);
}

if (tournamentFilter !== 'all') {
  countQuery = countQuery.contains("tournament_ids", [tournamentFilter]);
}

if (teamFilter !== 'all') {
  countQuery = countQuery.or(`team_a_id.eq.${teamFilter},team_b_id.eq.${teamFilter}`);
}

if (yearFilter !== 'all') {
  countQuery = countQuery.eq("game_year", yearFilter as any);
}

if (verifiedFilter === 'verified') {
  countQuery = countQuery.eq("is_verified", true);
} else if (verifiedFilter === 'unverified') {
  countQuery = countQuery.eq("is_verified", false);
}

if (stageFilter !== 'all') {
  countQuery = countQuery.eq("stage", stageFilter as any);
}

if (playerSearch) {
  countQuery = countQuery.or(`mvp_name.ilike.%${playerSearch}%`);
}

const { count } = await countQuery;
const totalPages = Math.ceil((count || 0) / MATCHES_PER_PAGE);

// Build data query with same filters
let dataQuery = supa((Astro.locals as any).runtime)
  .from("match_analytics_mart")
  .select("*");

if (leagueFilter !== 'all') {
  dataQuery = dataQuery.contains("season_ids", [leagueFilter]);
}

if (tournamentFilter !== 'all') {
  dataQuery = dataQuery.contains("tournament_ids", [tournamentFilter]);
}

if (teamFilter !== 'all') {
  dataQuery = dataQuery.or(`team_a_id.eq.${teamFilter},team_b_id.eq.${teamFilter}`);
}

if (yearFilter !== 'all') {
  dataQuery = dataQuery.eq("game_year", yearFilter as any);
}

if (verifiedFilter === 'verified') {
  dataQuery = dataQuery.eq("is_verified", true);
} else if (verifiedFilter === 'unverified') {
  dataQuery = dataQuery.eq("is_verified", false);
}

if (stageFilter !== 'all') {
  dataQuery = dataQuery.eq("stage", stageFilter as any);
}

if (playerSearch) {
  dataQuery = dataQuery.or(`mvp_name.ilike.%${playerSearch}%`);
}

const { data: matchesData, error } = await dataQuery
  .order("played_at", { ascending: false })
  .range(offset, offset + MATCHES_PER_PAGE - 1);

if (error) console.error(error);

// Map match_analytics_mart to expected format
const matches = (matchesData ?? []).map((m: any) => ({
  id: m.match_id,
  played_at: m.played_at,
  team_a_id: m.team_a_id,
  team_b_id: m.team_b_id,
  score_a: m.score_a,
  score_b: m.score_b,
  stage: m.stage,
  game_year: m.game_year,
  boxscore_url: null, // Not in mart
  status: m.is_verified ? 'verified' : 'processed', // 'processed' for under review
  verified: m.is_verified,
  team_a: {
    id: m.team_a_id,
    name: m.team_a_name,
    logo_url: m.team_a_logo,
  },
  team_b: {
    id: m.team_b_id,
    name: m.team_b_name,
    logo_url: m.team_b_logo,
  },
  league: m.league_name ? {
    season_id: m.season_ids?.[0],
    league_name: m.league_name,
    season_number: null, // Not available in mart
  } : null,
  tournament: m.tournament_name ? {
    id: m.tournament_ids?.[0],
    name: m.tournament_name,
  } : null,
}));

// Generate page numbers for pagination
function getPageNumbers(current: number, total: number): number[] {
  const maxVisible = Math.min(7, total);
  const pages: number[] = [];
  
  if (total <= 7) {
    for (let i = 1; i <= total; i++) pages.push(i);
  } else if (current <= 4) {
    for (let i = 1; i <= 7; i++) pages.push(i);
  } else if (current >= total - 3) {
    for (let i = total - 6; i <= total; i++) pages.push(i);
  } else {
    for (let i = current - 3; i <= current + 3; i++) pages.push(i);
  }
  
  return pages;
}

const pageNumbers = getPageNumbers(currentPage, totalPages);

// Fetch filter options
// Get available leagues/seasons from league_season_performance_mart
const { data: filterLeaguesData } = await supa((Astro.locals as any).runtime)
  .from("league_season_performance_mart")
  .select("season_id, league_name, season_number")
  .order("league_name", { ascending: true });

const leagueOptions = (filterLeaguesData ?? []).map((l: any) => ({
  value: l.season_id,
  label: `${l.league_name}${l.season_number ? ` S${l.season_number}` : ''}`
}));

// Get available tournaments from tournament_performance_mart
const { data: filterTournamentsData } = await supa((Astro.locals as any).runtime)
  .from("tournament_performance_mart")
  .select("tournament_id, tournament_name")
  .order("tournament_name", { ascending: true });

const tournamentOptions = (filterTournamentsData ?? []).map((t: any) => ({
  value: t.tournament_id,
  label: t.tournament_name
}));

// Get available teams from team_analytics_mart
const { data: filterTeamsData } = await supa((Astro.locals as any).runtime)
  .from("team_analytics_mart")
  .select("team_id, team_name")
  .order("team_name", { ascending: true });

const teamOptions = (filterTeamsData ?? []).map((t: any) => ({
  value: t.team_id,
  label: t.team_name
}));

// Get available years from match_analytics_mart
const { data: yearsData } = await supa((Astro.locals as any).runtime)
  .from("match_analytics_mart")
  .select("game_year")
  .not("game_year", "is", null);

const uniqueYears = [...new Set((yearsData ?? []).map((y: any) => y.game_year))].filter(Boolean).sort().reverse();

// Get available stages from match_analytics_mart
const { data: stagesData } = await supa((Astro.locals as any).runtime)
  .from("match_analytics_mart")
  .select("stage")
  .not("stage", "is", null);

const uniqueStages = [...new Set((stagesData ?? []).map((s: any) => s.stage))].filter(Boolean).sort();

// Build filter query for pagination links
const filterQuery = buildFilterQuery({
  league: leagueFilter,
  tournament: tournamentFilter,
  team: teamFilter,
  year: yearFilter,
  verified: verifiedFilter,
  stage: stageFilter,
  player: playerSearch
});

// Check if filters are active
const filtersActive = hasActiveFilters(
  { league: leagueFilter, tournament: tournamentFilter, team: teamFilter, year: yearFilter, verified: verifiedFilter, stage: stageFilter, player: playerSearch },
  { league: 'all', tournament: 'all', team: 'all', year: 'all', verified: 'all', stage: 'all', player: '' }
);
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Recent Matches - Pro-Am Rankings</title>
  </head>
  <body class="bg-neutral-950 text-white">
    <Navigation />
    <main class="mx-auto max-w-6xl p-6">
      <div class="mb-6">
        <div class="flex items-center justify-between mb-4">
          <h1 class="text-2xl font-bold">Recent Matches</h1>
          <div class="text-sm text-neutral-400">
            Page {currentPage} of {totalPages} • {count || 0} total matches
          </div>
        </div>

        <!-- Filters -->
        <div class="flex flex-wrap gap-3 mb-4">
          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">Player:</label>
            <input
              type="text"
              id="playerInput"
              placeholder="Player name..."
              value={playerSearch}
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm w-48"
              onkeydown="if (event.key === 'Enter') window.location.href = updateFilter('player', this.value)"
            />
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">League:</label>
            <select 
              id="leagueFilter"
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm max-w-[200px]"
              onchange="window.location.href = updateFilter('league', this.value)"
            >
              <option value="all" selected={leagueFilter === 'all'}>All Leagues</option>
              {leagueOptions.map((league) => (
                <option value={league.value} selected={leagueFilter === league.value}>{league.label}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">Tournament:</label>
            <select 
              id="tournamentFilter"
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm max-w-[200px]"
              onchange="window.location.href = updateFilter('tournament', this.value)"
            >
              <option value="all" selected={tournamentFilter === 'all'}>All Tournaments</option>
              {tournamentOptions.map((tournament) => (
                <option value={tournament.value} selected={tournamentFilter === tournament.value}>{tournament.label}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">Team:</label>
            <select 
              id="teamFilter"
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm max-w-[200px]"
              onchange="window.location.href = updateFilter('team', this.value)"
            >
              <option value="all" selected={teamFilter === 'all'}>All Teams</option>
              {teamOptions.map((team) => (
                <option value={team.value} selected={teamFilter === team.value}>{team.label}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">Year:</label>
            <select 
              id="yearFilter"
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm"
              onchange="window.location.href = updateFilter('year', this.value)"
            >
              <option value="all" selected={yearFilter === 'all'}>All Years</option>
              {uniqueYears.map((year: string) => (
                <option value={year} selected={yearFilter === year}>{year}</option>
              ))}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">Status:</label>
            <select 
              id="verifiedFilter"
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm"
              onchange="window.location.href = updateFilter('verified', this.value)"
            >
              <option value="all" selected={verifiedFilter === 'all'}>All</option>
              <option value="verified" selected={verifiedFilter === 'verified'}>Verified</option>
              <option value="review" selected={verifiedFilter === 'review'}>Under Review</option>
              <option value="unverified" selected={verifiedFilter === 'unverified'}>Unverified</option>
            </select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-neutral-400">Stage:</label>
            <select 
              id="stageFilter"
              class="px-3 py-1 rounded bg-neutral-800 border border-neutral-700 text-sm"
              onchange="window.location.href = updateFilter('stage', this.value)"
            >
              <option value="all" selected={stageFilter === 'all'}>All Stages</option>
              {uniqueStages.map((stage: string) => (
                <option value={stage} selected={stageFilter === stage}>{stage}</option>
              ))}
            </select>
          </div>

          {filtersActive && (
            <a 
              href="/matches" 
              class="px-3 py-1 rounded bg-neutral-800 hover:bg-neutral-700 transition text-sm"
            >
              Clear Filters
            </a>
          )}
        </div>
      </div>

      <script is:inline>
        function updateFilter(param, value) {
          const url = new URL(window.location.href);
          if (value === 'all' || (param === 'player' && value === '')) {
            url.searchParams.delete(param);
          } else {
            url.searchParams.set(param, value);
          }
          url.searchParams.delete('page'); // Reset to page 1 when filtering
          return url.toString();
        }
      </script>

      <!-- Verification Info Notice -->
      <div class="mb-6 p-4 rounded-lg border border-blue-500/30 bg-blue-900/10">
        <div class="flex items-start gap-3">
          <svg class="w-5 h-5 text-blue-400 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
          </svg>
          <div class="flex-1">
            <h3 class="text-sm font-semibold text-blue-300 mb-1">About Match Verification</h3>
            <p class="text-sm text-neutral-300">
              Unless a match has the <span class="text-green-300 font-medium">Verified</span> badge, stats were derived from OCR (Optical Character Recognition) and may contain errors. 
              Only verified stats are entered into our statistics tables and affect player ratings. 
              <a href="/ranking-system#verification" class="text-blue-400 hover:text-blue-300 underline">Learn more</a>
            </p>
          </div>
        </div>
      </div>

      <!-- Interactive Matches List (Astro Island) -->
      <MatchesListIsland client:load matches={matches} />

      {matches.length === 0 && (
        <div class="text-center py-12 text-neutral-400">
          No matches found.
        </div>
      )}

      <!-- Pagination -->
      {totalPages > 1 && (
        <div class="mt-8 flex items-center justify-center gap-2">
          {/* Previous Button */}
          {currentPage > 1 ? (
            <a
              href={`/matches?page=${currentPage - 1}${filterQuery}`}
              class="px-4 py-2 rounded bg-neutral-800 hover:bg-neutral-700 transition"
            >
              ← Previous
            </a>
          ) : (
            <span class="px-4 py-2 rounded bg-neutral-900 text-neutral-600 cursor-not-allowed">
              ← Previous
            </span>
          )}

          {/* Page Numbers */}
          <div class="flex gap-1">
            {pageNumbers.map((pageNum: number) => (
              <a
                href={`/matches?page=${pageNum}${filterQuery}`}
                class={`px-3 py-2 rounded transition ${
                  pageNum === currentPage
                    ? 'bg-blue-600 text-white font-semibold'
                    : 'bg-neutral-800 hover:bg-neutral-700'
                }`}
              >
                {pageNum}
              </a>
            ))}
          </div>

          {/* Next Button */}
          {currentPage < totalPages ? (
            <a
              href={`/matches?page=${currentPage + 1}${filterQuery}`}
              class="px-4 py-2 rounded bg-neutral-800 hover:bg-neutral-700 transition"
            >
              Next →
            </a>
          ) : (
            <span class="px-4 py-2 rounded bg-neutral-900 text-neutral-600 cursor-not-allowed">
              Next →
            </span>
          )}
        </div>
      )}
    </main>
  </body>
</html>

